<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Solfège + Lyrics + Kodály Viewer (v9, CSS Scaling)</title>

<!-- ABCjs (basic build) -->
<script src="https://cdn.jsdelivr.net/npm/abcjs@6.4.3/dist/abcjs-basic.min.js"></script>

<style>
  body {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    padding: 20px;
  }
  #container {
    max-width: 960px;
    margin: 0 auto;
  }
  textarea {
    width: 100%;
    height: 160px;
    font-family: monospace;
    display: none;
  }
  button {
    margin-top: 8px;
    padding: 8px 14px;
    font-size: 14px;
  }
  .controls-row {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
    margin-top: 8px;
  }
  label {
    font-size: 14px;
  }
  input[type="number"] {
    width: 60px;
  }
  .paper-wrapper {
    border: 1px solid #ddd;
    padding: 32px 12px 60px 12px; /* extra top + bottom padding for overlays */
    margin-top: 18px;
    overflow: visible;
  }
  /* ABCjs sets inline overflow: hidden on each render target div; force visibility so annotations show */
  .paper-wrapper > div {
    overflow: visible !important;
  }
  .level-label {
    margin-top: 24px;
    font-weight: 600;
  }

  /* We scale this container, not ABCjs internals */
  #levels-scale-wrapper {
    transform-origin: top left;
  }

  .solfege-text {
    font-size: 14px;
    font-weight: 700;
    text-anchor: middle;
    dominant-baseline: auto;
  }
  .kodaly-text {
    font-size: 22px;
    text-anchor: middle;
    dominant-baseline: auto;
    font-family: "Bravura Text", "Bravura", serif;
  }
</style>
</head>

<body>
<div id="container">

  <h1 id="main-title" style="margin-top:0; margin-bottom:48px; font-size:2.2em; font-weight:700; text-align:center;">Solfège + Lyrics + Kodály Viewer</h1>
    <div id="song-title" style="margin-bottom:48px; font-size:1.5em; font-weight:600; text-align:center;"></div>
  <div style="height:48px;"></div>
  <div style="height:32px;"></div>

  <textarea id="abc-input">
X:1
T:Twinkle Twinkle Little Star
M:4/4
L:1/4
K:C
C C G G | A A G2 |
w: Twin- kle, twin- kle, lit- tle star,
F F E E | D D C2 |
w: How I won- der what you are.
G G F F | E E D2 |
w: Up a- bove the world so high,
G G F F | E E D2 |
w: Like a di- a- mond in the sky.
C C G G | A A G2 |
w: Twin- kle, twin- kle, lit- tle star,
F F E E | D D C2 |
w: How I won- der what you are.

  </textarea>

  <div class="controls-row">

    <label>
      View Size:
      <select id="preset-select">
        <option value="large">Large (staffwidth 900, scale 2.5)</option>
        <option value="medium">Medium (staffwidth 900, scale 2.0)</option>
        <option value="default" selected>Default (staffwidth 900, scale 1.5)</option>
        <option value="small">Small (staffwidth 600, scale 1.2)</option>
        <option value="compact">Compact (staffwidth 400, scale 1.0)</option>
      </select>
    </label>

    <label>
      <input id="kodaly-toggle" type="checkbox" checked>
      Show Kodály signs
    </label>

    <!-- Temporary debug controls -->
    <label>
      Debug Scale:
      <input id="scale-input" type="number" step="0.1" min="0.5" max="3.0" placeholder="(use preset)">
    </label>

    <label>
      Debug Staffwidth:
      <input id="staffwidth-input" type="number" step="10" min="200" max="1200" placeholder="(use preset)">
    </label>

    <!-- Render buttons removed per request -->
  </div>

  <!-- Everything inside here gets scaled together -->
  <div id="levels-scale-wrapper">
    <div id="levels-container"></div>
  </div>
</div>

<script>
/* ------------ CONFIG ------------ */

const ORIGINAL_TONIC_PC = 0; // treat C as reference for movable-do

const DEGREE_COLORS = {
  0:"#ff3b30", // Do
  1:"#ff9500", // Re
  2:"#ffcc00", // Mi
  3:"#34c759", // Fa
  4:"#007aff", // So
  5:"#af52de", // La
  6:"#5ac8fa"  // Ti
};

// SMuFL Kodály (Bravura Text)
const KODALY_GLYPHS = {
  0:"\uEC40",
  1:"\uEC41",
  2:"\uEC42",
  3:"\uEC43",
  4:"\uEC44",
  5:"\uEC45",
  6:"\uEC46"
};

const SCALE_LEVELS = [
  { label:"Do on C (0)", transposeSemis:0 },
  { label:"Do on D (+2)", transposeSemis:2 },
  { label:"Do on F (+5)", transposeSemis:5 }
];

function getRenderSizing() {
  const preset = document.getElementById('preset-select')?.value || 'medium';
  // Base from preset as requested
  let staffwidth = 900;
  let scale = 1.5; // default
  if (preset === 'large') scale = 2.5;
  else if (preset === 'medium') scale = 2.0;
  else if (preset === 'small') {
    staffwidth = 600;
    scale = 1.2;
  }
  else if (preset === 'compact') {
    staffwidth = 400;
    scale = 1.0;
  }

  // Debug overrides if provided
  const scaleInput = document.getElementById('scale-input');
  const staffwidthInput = document.getElementById('staffwidth-input');
  const sVal = parseFloat(scaleInput?.value);
  const wVal = parseInt(staffwidthInput?.value, 10);
  if (!Number.isNaN(sVal) && sVal > 0.1) scale = sVal;
  if (!Number.isNaN(wVal) && wVal >= 100) staffwidth = wVal;
  return { staffwidth, scale };
}

/* ------------ ABC HELPERS ------------ */

// Insert spacing directives if not present so ABCjs adds room
// between the title block and the first staff (and between staves).
function preprocessAbcForSpacing(abc, opts = { max: 120, sep: 90 }) {
  const hasStaffsep = /^(%%\s*staffsep)\b/im.test(abc);
  const hasMaxStaffsep = /^(%%\s*maxstaffsep)\b/im.test(abc);
  if (hasStaffsep && hasMaxStaffsep) return abc;

  const insert = [
    hasMaxStaffsep ? null : `%%maxstaffsep ${opts.max}`,
    hasStaffsep ? null : `%%staffsep ${opts.sep}`
  ].filter(Boolean).join("\n");
  if (!insert) return abc;

  // Place right before the first K: line if found; else prepend.
  if (/^K:[^\n]*$/m.test(abc)) {
    return abc.replace(/^(K:[^\n]*$)/m, insert + "\n$1");
  }
  return insert + "\n" + abc;
}

function extractPitchLettersFromAbc(abc) {
  const lines = abc.split(/\r?\n/);
  const letters = [];

  for (const line of lines) {
    const t = line.trim();
    if (/^[A-Za-z]:/.test(t)) continue;
    if (/^w:/.test(t)) continue;

    const tokens = t.split(/[\s\|]+/).filter(Boolean);
    for (const token of tokens) {
      const m = token.match(/[A-Ga-g]/);
      if (!m) continue;
      const L = m[0];
      if (L.toLowerCase() === "z") continue; // rest
      letters.push(L);
    }
  }
  return letters;
}

function pitchLetterToPitchClass(letter) {
  switch (letter.toUpperCase()) {
    case "C": return 0;
    case "D": return 2;
    case "E": return 4;
    case "F": return 5;
    case "G": return 7;
    case "A": return 9;
    case "B": return 11;
  }
  return null;
}

function pitchClassToSolfege(pc, tonicPc) {
  const iv = (pc - tonicPc + 12) % 12;
  switch (iv) {
    case 0:  return { syllable:"Do", degree:0 };
    case 2:  return { syllable:"Re", degree:1 };
    case 4:  return { syllable:"Mi", degree:2 };
    case 5:  return { syllable:"Fa", degree:3 };
    case 7:  return { syllable:"So", degree:4 };
    case 9:  return { syllable:"La", degree:5 };
    case 11: return { syllable:"Ti", degree:6 };
    // chromatic placeholders
    case 1:  return { syllable:"Di", degree:0 };
    case 3:  return { syllable:"Ri", degree:1 };
    case 6:  return { syllable:"Fi", degree:3 };
    case 8:  return { syllable:"Si", degree:4 };
    case 10: return { syllable:"Li", degree:5 };
    default: return { syllable:"?", degree:0 };
  }
}

function buildSolfegeSequence(baseLetters, transposeSemis) {
  const tonicPc = (ORIGINAL_TONIC_PC + transposeSemis + 12) % 12;
  return baseLetters.map(L => {
    const pc = pitchLetterToPitchClass(L);
    if (pc === null) return { syllable:"", degree:0 };
    const pcT = (pc + transposeSemis + 12) % 12;
    return pitchClassToSolfege(pcT, tonicPc);
  });
}

/* ------------ SYSTEM CLUSTERING (FOR OVERLAYS ABOVE STAFF) ------------ */

// Cluster notes by vertical position into "systems" so each system
// gets its own solfege/Kodály baselines above the staff.
function computeSystemBaselines(noteGroups) {
  const items = [];

  noteGroups.forEach((g, i) => {
    const bb = g.getBBox();
    const top = bb.y;
    const yCenter = bb.y + bb.height / 2;
    items.push({ index:i, yCenter, top });
  });

  items.sort((a,b) => a.yCenter - b.yCenter);

  const clusters = [];
  let current = null;
  const THRESHOLD = 25; // vertical distance threshold between systems

  for (const it of items) {
    if (!current) {
      current = { indices:[it.index], minTop:it.top, lastY:it.yCenter };
    } else {
      if (Math.abs(it.yCenter - current.lastY) > THRESHOLD) {
        clusters.push(current);
        current = { indices:[it.index], minTop:it.top, lastY:it.yCenter };
      } else {
        current.indices.push(it.index);
        current.minTop = Math.min(current.minTop, it.top);
        current.lastY = it.yCenter;
      }
    }
  }
  if (current) clusters.push(current);

  const noteIndexToCluster = new Array(noteGroups.length);
  clusters.forEach((cl, ci) => {
    cl.indices.forEach(idx => {
      noteIndexToCluster[idx] = ci;
    });
  });

  // Baselines ABOVE the staff (so they don't collide with lyrics below)
  let baselines = clusters.map(cl => {
    const top = cl.minTop;   // top of noteheads for that system
    return {
      kodaly: top - 10,      // hand signs closest to staff
      solfege: top - 26      // solfege above Kodály
    };
  });

  // Prevent first-system overlays from being cropped: ensure a minimum y
  // position for solfege; shift both solfege and kodaly down if needed.
  const MIN_SOLFEGE_Y = 14; // tweakable safety margin
  baselines = baselines.map(bl => {
    const delta = bl.solfege < MIN_SOLFEGE_Y ? (MIN_SOLFEGE_Y - bl.solfege) : 0;
    if (delta > 0) {
      return { solfege: bl.solfege + delta, kodaly: bl.kodaly + delta };
    }
    return bl;
  });

  return { noteIndexToCluster, baselines };
}

/* ------------ OVERLAY DRAWING (SOLFÈGE ABOVE STAFF) ------------ */

function ensureSvgViewportHeight(svg, minNeeded) {
  const vb = svg.getAttribute("viewBox");
  let vbParts = null;
  if (vb) {
    vbParts = vb.split(/\s+/).map(Number);
    if (vbParts.length === 4 && !Number.isNaN(vbParts[3])) {
      const curH = vbParts[3];
      const needH = Math.max(curH, minNeeded + 20);
      if (needH > curH) {
        vbParts[3] = needH;
        svg.setAttribute("viewBox", vbParts.join(" "));
      }
    }
  }
  const hAttr = svg.getAttribute("height");
  const curAttrH = hAttr ? parseFloat(hAttr) : null;
  const fallbackH = (vbParts && vbParts.length === 4) ? vbParts[3] : curAttrH || (minNeeded + 20);
  const needAttrH = Math.max(fallbackH, minNeeded + 20);
  if (!curAttrH || needAttrH > curAttrH) {
    svg.setAttribute("height", String(needAttrH));
    svg.style.height = needAttrH + "px";
  }
}

function overlaySolfegeAndKodaly(svg, solfegeSeq, showKodaly, startIndex = 0) {
  let notes = Array.from(svg.querySelectorAll("g.abcjs-note"));
  if (!notes.length) {
    notes = Array.from(svg.querySelectorAll("g.abcjs-n"));
  }
  if (!notes.length) return;

  // Remove old overlays if re-rendering
  svg.querySelectorAll("text.solfege-text, text.kodaly-text").forEach(e => e.remove());

  // Ensure SVG is not clipped
  svg.style.overflow = "visible";
  svg.setAttribute("overflow", "visible");

  const sys = computeSystemBaselines(notes);
  
  // Compute a baseline BELOW the lyrics: find the bottom-most element among
  // noteheads and any lyric text, then place Kodály and solfege under that.
  let maxBottom = 0;
  notes.forEach(n => {
    const bb = n.getBBox();
    maxBottom = Math.max(maxBottom, bb.y + bb.height);
  });
  const lyricTexts = Array.from(svg.querySelectorAll('text[class*="lyric"], g[class*="lyric"] text'));
  lyricTexts.forEach(t => {
    const bb = t.getBBox();
    maxBottom = Math.max(maxBottom, bb.y + bb.height);
  });
  const BELOW_KODALY_OFFSET = 13;
  const BELOW_SOLFEGE_OFFSET = 26;

  // Ensure the SVG viewport is tall enough to show annotations below lyrics.
  ensureSvgViewportHeight(svg, maxBottom + BELOW_SOLFEGE_OFFSET + 10);
  
  // Also ensure parent container doesn't clip
  svg.parentElement.style.overflow = "visible";

  const effectiveBaselines = (sys.baselines || []).map(() => ({
    kodaly: maxBottom + BELOW_KODALY_OFFSET,
    solfege: maxBottom + BELOW_SOLFEGE_OFFSET
  }));

  let annotationMaxBottom = maxBottom + BELOW_SOLFEGE_OFFSET;

  notes.forEach((noteG, i) => {
    const sf = solfegeSeq[startIndex + i];
    if (!sf || !sf.syllable) return;

    const bb = noteG.getBBox();
    const noteX = bb.x + bb.width / 2;

    const ci = sys.noteIndexToCluster[i];
    if (ci == null) return;
    const bl = effectiveBaselines[ci] || { kodaly: maxBottom + BELOW_KODALY_OFFSET, solfege: maxBottom + BELOW_SOLFEGE_OFFSET };

    const color = DEGREE_COLORS[sf.degree] || "#111";

    // Color notehead
    const head = noteG.querySelector("path");
    if (head) {
      head.setAttribute("fill", color);
      head.setAttribute("stroke", color);
    }

    // Solfege text below the lyrics
    const solY = bl.solfege;
    const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
    t.setAttribute("x", noteX);
    t.setAttribute("y", solY);
    t.setAttribute("class", "solfege-text");
    t.setAttribute("fill", color);
    t.textContent = sf.syllable;
    svg.appendChild(t);
    const solBox = t.getBBox();
    annotationMaxBottom = Math.max(annotationMaxBottom, solBox.y + solBox.height);

    // Kodály signs between solfege and staff
    if (showKodaly && KODALY_GLYPHS.hasOwnProperty(sf.degree)) {
      const kodY = bl.kodaly;
      const k = document.createElementNS("http://www.w3.org/2000/svg", "text");
      k.setAttribute("x", noteX);
      k.setAttribute("y", kodY);
      k.setAttribute("class", "kodaly-text");
      k.textContent = KODALY_GLYPHS[sf.degree];
      svg.appendChild(k);
      const kodBox = k.getBBox();
      annotationMaxBottom = Math.max(annotationMaxBottom, kodBox.y + kodBox.height);
    }
  });

  ensureSvgViewportHeight(svg, annotationMaxBottom + 10);

  return notes.length;
}

/* ------------ RENDERING ------------ */

function renderLevel(abc, baseLetters, targetId, transposeSemis, showKodaly) {
  const target = document.getElementById(targetId);
  target.innerHTML = "";

  // Get sizing from preset + debug overrides
  const { staffwidth, scale } = getRenderSizing();

  const engraverParams = {
    add_classes: true,
    staffwidth,
    scale,
    "top-margin": 72,
    wrap: true,
    oneSvgPerLine: true
  };

  const tuneObjs = ABCJS.renderAbc(targetId, abc, {}, engraverParams);
  if (!tuneObjs || !tuneObjs.length) return;

  // With oneSvgPerLine, multiple SVGs may be created. Process each.
  const svgs = Array.from(target.querySelectorAll("svg"));
  if (!svgs.length) return;

  const solfegeSeq = buildSolfegeSequence(baseLetters, transposeSemis);
  let offset = 0;
  svgs.forEach(s => {
    const processed = overlaySolfegeAndKodaly(s, solfegeSeq, showKodaly, offset) || 0;
    offset += processed;
  });


}

function applyZoom() {
  // No longer needed; scaling handled by ABCjs
}

function renderSingle() {
  const abcRaw = document.getElementById("abc-input").value;
  const abc = preprocessAbcForSpacing(abcRaw);
    // Extract song title from ABC (T: line)
    const titleMatch = abcRaw.match(/^T:(.*)$/m);
    const songTitle = titleMatch ? titleMatch[1].trim() : "";
    // If ABC has T:, let ABCjs render the title and clear the HTML title to avoid duplication.
    document.getElementById("song-title").textContent = titleMatch ? "" : songTitle;

    const baseLetters = extractPitchLettersFromAbc(abcRaw);
    const showKodaly = document.getElementById("kodaly-toggle").checked;

    const container = document.getElementById("levels-container");
    container.innerHTML = "";

    const label = document.createElement("div");
    label.className = "level-label";
    label.textContent = "Single Level (Do on C)";
    container.appendChild(label);

    const paperWrap = document.createElement("div");
    paperWrap.className = "paper-wrapper";
    const paperId = "paper-single";
    paperWrap.innerHTML = `<div id="${paperId}"></div>`;
    container.appendChild(paperWrap);

    renderLevel(abc, baseLetters, paperId, 0, showKodaly);
  // No longer needed; scaling handled by ABCjs
}

function renderMulti() {
  const abcRaw = document.getElementById("abc-input").value;
  const abc = preprocessAbcForSpacing(abcRaw);
    // Extract song title from ABC (T: line)
    const titleMatch = abcRaw.match(/^T:(.*)$/m);
    const songTitle = titleMatch ? titleMatch[1].trim() : "";
    document.getElementById("song-title").textContent = titleMatch ? "" : songTitle;

    const baseLetters = extractPitchLettersFromAbc(abcRaw);
    const showKodaly = document.getElementById("kodaly-toggle").checked;

    const container = document.getElementById("levels-container");
    container.innerHTML = "";

    SCALE_LEVELS.forEach((level, idx) => {
      const label = document.createElement("div");
      label.className = "level-label";
      label.textContent = level.label;
      container.appendChild(label);

      const paperWrap = document.createElement("div");
      paperWrap.className = "paper-wrapper";
      const paperId = `paper-${idx}`;
      paperWrap.innerHTML = `<div id="${paperId}"></div>`;
      container.appendChild(paperWrap);

      renderLevel(abc, baseLetters, paperId, level.transposeSemis, showKodaly);
    });

  // No longer needed; scaling handled by ABCjs
}

// Helper to re-render the single view on control changes
function rerender() { renderSingle(); }

/* ------------ UI HOOKUP ------------ */

// Removed render buttons; re-render on control changes
document.getElementById("preset-select").addEventListener("change", rerender);
document.getElementById("scale-input").addEventListener("change", rerender);
document.getElementById("staffwidth-input").addEventListener("change", rerender);
document.getElementById("kodaly-toggle").addEventListener("change", rerender);
window.addEventListener("load", function() {
  // Show initial song title
  const abc = document.getElementById("abc-input").value;
  const titleMatch = abc.match(/^T:(.*)$/m);
  const songTitle = titleMatch ? titleMatch[1].trim() : "";
  document.getElementById("song-title").textContent = titleMatch ? "" : songTitle;
  // Initialize debug inputs to preset-derived values for discoverability
  const sizing = getRenderSizing();
  const sEl = document.getElementById('scale-input');
  const wEl = document.getElementById('staffwidth-input');
  if (sEl && !sEl.value) sEl.placeholder = sizing.scale.toString();
  if (wEl && !wEl.value) wEl.placeholder = sizing.staffwidth.toString();
  renderSingle();
});
</script>
</body>
</html>
